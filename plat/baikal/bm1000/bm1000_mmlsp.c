/*
 * Copyright (c) 2018-2021, Baikal Electronics, JSC. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <baikal_gpio32.h>
#include <bm1000_cmu.h>
#include <bm1000_private.h>
#include <drivers/delay_timer.h>
#include <lib/mmio.h>
#include <platform_def.h>

/* Resets */
#define MMAVLSP_ASYNCRES_REG			(MMAVLSP_LCRU + LCRU_GPR + 0x00)
enum {
	MMAVLSP_ASYNCRES_REG_CFG_NICS_RES   = BIT(0),
	MMAVLSP_ASYNCRES_REG_CFG_NICM_RES   = BIT(1),
	MMAVLSP_ASYNCRES_REG_DMA_NICS_RES   = BIT(2),
	MMAVLSP_ASYNCRES_REG_DMA_NICM_RES   = BIT(3),
	MMAVLSP_ASYNCRES_REG_DMAC_RES	    = BIT(6),
	MMAVLSP_ASYNCRES_REG_MMU_RES	    = BIT(7),
	MMAVLSP_ASYNCRES_REG_GPIO_RES	    = BIT(10),
	MMAVLSP_ASYNCRES_REG_UART1_RES	    = BIT(11),
	MMAVLSP_ASYNCRES_REG_UART2_RES	    = BIT(12),
	MMAVLSP_ASYNCRES_REG_SPI_RES	    = BIT(13),
	MMAVLSP_ASYNCRES_REG_ESPI_RES	    = BIT(14),
	MMAVLSP_ASYNCRES_REG_I2C1_RES	    = BIT(15),
	MMAVLSP_ASYNCRES_REG_I2C2_RES	    = BIT(16),
	MMAVLSP_ASYNCRES_REG_TIMER1_RES	    = BIT(17),
	MMAVLSP_ASYNCRES_REG_TIMER2_RES	    = BIT(18),
	MMAVLSP_ASYNCRES_REG_TIMER3_RES	    = BIT(19),
	MMAVLSP_ASYNCRES_REG_TIMER4_RES	    = BIT(20),
	MMAVLSP_ASYNCRES_REG_SMBUS_I2C1_RES = BIT(21),
	MMAVLSP_ASYNCRES_REG_SMBUS_I2C2_RES = BIT(22),
	MMAVLSP_ASYNCRES_REG_GPIO_APB_RES   = BIT(23),
	MMAVLSP_ASYNCRES_REG_UART1_APB_RES  = BIT(24),
	MMAVLSP_ASYNCRES_REG_UART2_APB_RES  = BIT(25),
	MMAVLSP_ASYNCRES_REG_SPI_APB_RES    = BIT(26),
	MMAVLSP_ASYNCRES_REG_ESPI_APB_RES   = BIT(27),
	MMAVLSP_ASYNCRES_REG_I2C1_APB_RES   = BIT(28),
	MMAVLSP_ASYNCRES_REG_I2C2_APB_RES   = BIT(29),
	MMAVLSP_ASYNCRES_REG_TIMERS_APB_RES = BIT(30),
	MMAVLSP_ASYNCRES_REG_I2S_APB_RES    = BIT(31)
};

#define MMAVLSP_ASYNCRES1_REG			(MMAVLSP_LCRU + LCRU_GPR + 0x08)
enum {
	MMAVLSP_ASYNCRES1_REG_HDA_RES	       = BIT(0),
	MMAVLSP_ASYNCRES1_REG_MSHC_AXI_RES     = BIT(1),
	MMAVLSP_ASYNCRES1_REG_MSHC_AHB_RES     = BIT(2),
	MMAVLSP_ASYNCRES1_REG_MSHC_C_RES       = BIT(3),
	MMAVLSP_ASYNCRES1_REG_MSHC_B_RES       = BIT(4),
	MMAVLSP_ASYNCRES1_REG_MSHC_T_RES       = BIT(5),
	MMAVLSP_ASYNCRES1_REG_CQET_RES	       = BIT(6),
	MMAVLSP_ASYNCRES1_REG_TUNING_SDCLK_RES = BIT(7),
	MMAVLSP_ASYNCRES1_REG_VDU_AXI_RES      = BIT(8),
	MMAVLSP_ASYNCRES1_REG_HWA_CLU_RES      = BIT(9),
	MMAVLSP_ASYNCRES1_REG_HWA_CLU_HF_RES   = BIT(10),
	MMAVLSP_ASYNCRES1_REG_HWA_AXI_MMU_RES  = BIT(11),
	MMAVLSP_ASYNCRES1_REG_HWA_CFG_RES      = BIT(12),
	MMAVLSP_ASYNCRES1_REG_VDU_PLL_RES      = BIT(13),
	MMAVLSP_ASYNCRES1_REG_CLOCK_24_RES     = BIT(14),
	MMAVLSP_ASYNCRES1_REG_I2S_RES	       = BIT(15)
};

#define MMAVLSP_MSHC_CFG_REG			(MMAVLSP_LCRU + LCRU_GPR + 0x20)
#define MMAVLSP_MSHC_CFG_REG_CLKDIV_SEL		BIT(16)

#define MMAVLSP_VDU_ARQOS_REG			(MMAVLSP_LCRU + LCRU_GPR + 0x30)
#define MMAVLSP_VDU_ARQOS_REG_ARQOS(x)		SETMASK(x, 7, 4)

#define MMAVLSP_VDU_CACHE_AND_DOMAIN_REG	(MMAVLSP_LCRU + LCRU_GPR + 0x50)
#define MMAVLSP_VDU_CACHE_AND_DOMAIN_REG_ARCACHE(x)	SETMASK(x, 3, 0)
#define MMAVLSP_VDU_CACHE_AND_DOMAIN_REG_ARDOMAIN(x)	SETMASK(x, 5, 4)

#define MMAVLSP_HDA_CACHE_AND_DOMAIN_REG	(MMAVLSP_LCRU + LCRU_GPR + 0x38)
#define MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_AWCACHE(x)	SETMASK(x,  3,  0)
#define MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_ARCACHE(x)	SETMASK(x,  7,  4)
#define MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_AWDOMAIN(x)	SETMASK(x,  9,  8)
#define MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_ARDOMAIN(x)	SETMASK(x, 11, 10)

#define MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG	(MMAVLSP_LCRU + LCRU_GPR + 0x48)
#define MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_AWCACHE(x)	SETMASK(x,  3,  0)
#define MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_ARCACHE(x)	SETMASK(x,  7,  4)
#define MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_AWDOMAIN(x)	SETMASK(x,  9,  8)
#define MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_ARDOMAIN(x)	SETMASK(x, 11, 10)

enum {
	MMAVLSP_CLKCH_GPIO	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(0),
	MMAVLSP_CLKCH_UART1	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(1),
	MMAVLSP_CLKCH_UART2	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(2),
	MMAVLSP_CLKCH_APB	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(3),
	MMAVLSP_CLKCH_SPI	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(4),
	MMAVLSP_CLKCH_ESPI	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(5),
	MMAVLSP_CLKCH_I2C1	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(6),
	MMAVLSP_CLKCH_I2C2	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(7),
	MMAVLSP_CLKCH_TIMER1	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(8),
	MMAVLSP_CLKCH_TIMER2	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(9),
	MMAVLSP_CLKCH_TIMER3	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(10),
	MMAVLSP_CLKCH_TIMER4	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(11),
	MMAVLSP_CLKCH_DMAC	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(12),
	MMAVLSP_CLKCH_SMBUS1	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(13),
	MMAVLSP_CLKCH_SMBUS2	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(14),
	MMAVLSP_CLKCH_HDA_SYS_CLK     = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(15),
	MMAVLSP_CLKCH_HDA_CLK48	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(16),
	MMAVLSP_CLKCH_MSHC_AXI	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(17),
	MMAVLSP_CLKCH_MSHC_AHB	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(18),
	MMAVLSP_CLKCH_MSHC_CCLK_TX_X2 = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(19),
	MMAVLSP_CLKCH_MSHC_BCLK	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(20),
	MMAVLSP_CLKCH_MSHC_TMCLK      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(21),
	MMAVLSP_CLKCH_MSHC_CQETMCLK   = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(22),
	MMAVLSP_CLKCH_HWA_CLU	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(23),
	MMAVLSP_CLKCH_HWA_CLU_HF      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(24),
	MMAVLSP_CLKCH_HWA_AXI_MMU     = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(25),
	MMAVLSP_CLKCH_VDU_AXI	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(26),
	MMAVLSP_CLKCH_SMMU	      = MMAVLSP_LCRU + LCRU_CMU0 + LCRU_CLKCH_OFFSET(27)
};

/* Clock dividers for AVLSP, based on 1200 MHz input clk */
enum {
	AVLSP_CLK_600MHZ  =    2,
	AVLSP_CLK_400MHZ  =    3,
	AVLSP_CLK_300MHZ  =    4,
	AVLSP_CLK_240MHZ  =    5,
	AVLSP_CLK_200MHZ  =    6,
	AVLSP_CLK_100MHZ  =   12,
	AVLSP_CLK_50MHZ	  =   24,
	AVLSP_CLK_48MHZ	  =   25,
	AVLSP_CLK_40MHZ	  =   30,
	AVLSP_CLK_25MHZ	  =   48,
	AVLSP_CLK_10MHZ	  =  120,
	AVLSP_CLK_8MHZ	  =  150,
	AVLSP_CLK_7P35MHZ =  163,
	AVLSP_CLK_1MHZ	  = 1200,
	AVLSP_CLK_800KHZ  = 1500
};

#define MMAVLSP_VDU_LCRU_PLL1_RESET_GPIO_PIN	17

void mmlsp_init(void)
{
	static const cmu_pll_ctl_vals_t avlsp_lcru_pll_init = {
		0, 0, 0x60, 0, 0, 0x2c, 0, 0x2c
	};

	cmu_pll_on(MMAVLSP_LCRU, &avlsp_lcru_pll_init);

	/* Clock channels, AVLSP BASE Clock 1200 MHz */
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_DMAC,	    AVLSP_CLK_200MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_SMMU,	    AVLSP_CLK_300MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_VDU_AXI,	    AVLSP_CLK_240MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_HWA_CLU,	    AVLSP_CLK_200MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_HWA_CLU_HF,  AVLSP_CLK_600MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_HWA_AXI_MMU, AVLSP_CLK_400MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_GPIO,	    AVLSP_CLK_8MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_I2C1,	    AVLSP_CLK_100MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_I2C2,	    AVLSP_CLK_100MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_UART1,	    AVLSP_CLK_7P35MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_UART2,	    AVLSP_CLK_7P35MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_SPI,	    AVLSP_CLK_50MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_ESPI,	    AVLSP_CLK_25MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_SMBUS1,	    AVLSP_CLK_50MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_SMBUS2,	    AVLSP_CLK_50MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_HDA_SYS_CLK, AVLSP_CLK_100MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_HDA_CLK48,   AVLSP_CLK_48MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_TIMER1,	    AVLSP_CLK_50MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_TIMER2,	    AVLSP_CLK_50MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_TIMER3,	    AVLSP_CLK_50MHZ);
	cmu_clkch_enable_by_base(MMAVLSP_CLKCH_TIMER4,	    AVLSP_CLK_50MHZ);

#if defined(BE_MBM10) && (BOARD_VER == 0)
	gpio32_dir_set(MMAVLSP_VDU_LCRU_PLL1_RESET_GPIO_PIN);
	gpio32_out_rst(MMAVLSP_VDU_LCRU_PLL1_RESET_GPIO_PIN);
	mdelay(10);
	gpio32_out_set(MMAVLSP_VDU_LCRU_PLL1_RESET_GPIO_PIN);
#endif

	/* Deassert reset signals */
	mmio_clrbits_32(MMAVLSP_ASYNCRES_REG,
			MMAVLSP_ASYNCRES_REG_CFG_NICM_RES   |
			MMAVLSP_ASYNCRES_REG_DMA_NICM_RES   |
			MMAVLSP_ASYNCRES_REG_DMA_NICS_RES   |
			MMAVLSP_ASYNCRES_REG_CFG_NICS_RES   |
			MMAVLSP_ASYNCRES_REG_GPIO_APB_RES   |
			MMAVLSP_ASYNCRES_REG_I2C1_APB_RES   |
			MMAVLSP_ASYNCRES_REG_I2C2_APB_RES   |
			MMAVLSP_ASYNCRES_REG_GPIO_RES	    |
			MMAVLSP_ASYNCRES_REG_I2C1_RES	    |
			MMAVLSP_ASYNCRES_REG_I2C2_RES	    |
			MMAVLSP_ASYNCRES_REG_UART1_RES	    |
			MMAVLSP_ASYNCRES_REG_UART2_RES	    |
			MMAVLSP_ASYNCRES_REG_UART1_APB_RES  |
			MMAVLSP_ASYNCRES_REG_UART2_APB_RES  |
			MMAVLSP_ASYNCRES_REG_SPI_RES	    |
			MMAVLSP_ASYNCRES_REG_ESPI_RES	    |
			MMAVLSP_ASYNCRES_REG_SPI_APB_RES    |
			MMAVLSP_ASYNCRES_REG_ESPI_APB_RES   |
			MMAVLSP_ASYNCRES_REG_SMBUS_I2C1_RES |
			MMAVLSP_ASYNCRES_REG_SMBUS_I2C2_RES |
			MMAVLSP_ASYNCRES_REG_I2S_APB_RES    |
#if 0
			MMAVLSP_ASYNCRES_REG_DMAC_RES	    |
#endif
			MMAVLSP_ASYNCRES_REG_TIMER1_RES	    |
			MMAVLSP_ASYNCRES_REG_TIMER2_RES	    |
			MMAVLSP_ASYNCRES_REG_TIMER3_RES	    |
			MMAVLSP_ASYNCRES_REG_TIMER4_RES	    |
			MMAVLSP_ASYNCRES_REG_TIMERS_APB_RES);

	mmio_clrbits_32(MMAVLSP_ASYNCRES_REG,
			MMAVLSP_ASYNCRES_REG_MMU_RES);

	mmio_clrbits_32(MMAVLSP_ASYNCRES1_REG,
			MMAVLSP_ASYNCRES1_REG_VDU_AXI_RES      |
			MMAVLSP_ASYNCRES1_REG_VDU_PLL_RES      |
			MMAVLSP_ASYNCRES1_REG_HDA_RES	       |
			MMAVLSP_ASYNCRES1_REG_HWA_CLU_RES      |
			MMAVLSP_ASYNCRES1_REG_HWA_CLU_HF_RES   |
			MMAVLSP_ASYNCRES1_REG_MSHC_AXI_RES     |
			MMAVLSP_ASYNCRES1_REG_MSHC_AHB_RES     |
			MMAVLSP_ASYNCRES1_REG_MSHC_C_RES       |
			MMAVLSP_ASYNCRES1_REG_MSHC_B_RES       |
			MMAVLSP_ASYNCRES1_REG_MSHC_T_RES       |
			MMAVLSP_ASYNCRES1_REG_CQET_RES	       |
			MMAVLSP_ASYNCRES1_REG_TUNING_SDCLK_RES |
			MMAVLSP_ASYNCRES1_REG_HWA_AXI_MMU_RES);

	/* VDU domain 2, cached */
	mmio_write_32(MMAVLSP_VDU_CACHE_AND_DOMAIN_REG,
		      MMAVLSP_VDU_CACHE_AND_DOMAIN_REG_ARDOMAIN(2) |
		      MMAVLSP_VDU_CACHE_AND_DOMAIN_REG_ARCACHE(0xb));

	mmio_write_32(MMAVLSP_VDU_ARQOS_REG,
		      MMAVLSP_VDU_ARQOS_REG_ARQOS(0xf));

	/* HD audio cache domain */
	mmio_write_32(MMAVLSP_HDA_CACHE_AND_DOMAIN_REG,
		      MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_ARDOMAIN(2)  |
		      MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_AWDOMAIN(2)  |
		      MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_ARCACHE(0xb) |
		      MMAVLSP_HDA_CACHE_AND_DOMAIN_REG_AWCACHE(0x7));

	/* MSHC cache domain */
	mmio_write_32(MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG,
		      MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_ARDOMAIN(2)  |
		      MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_AWDOMAIN(2)  |
		      MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_ARCACHE(0xb) |
		      MMAVLSP_MSHC_CACHE_AND_DOMAIN_REG_AWCACHE(0x7));

	/* MSHC enable frequency division */
	mmio_clrbits_32(MMAVLSP_MSHC_CFG_REG,
			MMAVLSP_MSHC_CFG_REG_CLKDIV_SEL);
}

void mmlsp_ns_access(void)
{
	mmio_write_32(BAIKAL_NIC_AVLSP_UART_1,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_UART_2,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_SPI,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_VDU,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_GPIO,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_I2C_1,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_I2C_2,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_SMBUS_1,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_SMBUS_2,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_I2S,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_HDA,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_TIMERS,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_SDC,	SECURE_MODE_OFF);
	mmio_write_32(BAIKAL_NIC_AVLSP_ESPI,	SECURE_MODE_OFF);
}
